额外补充,shell(not Makefile)：
1、$@
$@ 为传递的参数
2、$#
$# 为传递参数的数量

就像脚本执行后的结果：
 
Testing $@ and $#
-------------
Output $@
1.txt 2.txt
Output $#
2
3、$? 
    是shell变量,表示"最后一次执行命令"的退出状态，一般0表示成功，非0数值表示没有成功。
 
切记:
$?永远表示shell命令最后一次执行后的退出状态,当函数执行完毕后,如果又执行了其它命令,则$?不再表示函数执行后的状态,而表示其它命令的退出状态. 
4、$!
    代表pid,进程id
 
5、$$
    代表ppid,父进程id
	
	
	
	
	
	
1.使用IE 瀏覽器輸入下列網址
   https://firm.sunplus.com/
2.
账号zouhh   密码Li#98xy!


路徑：http://carwiki.sunplus.com/index.php/SPHE_8388 	



单点触摸(Single-touch)设备支持以下Linux输入事件: 
ABS_X: (必须) ：报告工具的x坐标 
ABS_Y: (必须) ：报告工具的y坐标 
BTN_TOUCH: (必须) ：指示工具是否接触触摸设备. 

多点触摸(Multi-touch)设备支持以下Linux输入事件: 
ABS_MT_POSITION_X: (必须)： 报告工具的X坐标 
ABS_MT_POSITION_Y: (必须)： 报告工具的X坐标 
BTN_TOUCH: (必须) ： 指示工具是否接触触摸设备

/---------------927/926寄存器设置-------------------------

927中gpio设置：
GPIO Function Enable
1: Enable GPIO operation		//gpio功能
0: Enable normal operation		//常规功能，即复用的功能


Note: 
if the DS90UB927Q-Q1 is paired with a DS90UB926Q-Q1 deserializer, the devices must be configured into 18-bit mode to allow usage of
GPIO pins on the DS90UB927 serializer. To enable 18-bit mode, set serializer register reg_0x12[2] = 1. 18-bit
mode will be auto-loaded into the deserializer from the serializer. 
意思是，如果927与926配对使用，必须把0x12寄存器的第[2]位设置为1，配置成 18-bit 模式，才能在927上允许使用GPIO引脚功能。

GPIO[0:3] 这4个gpio是可以用作透传的，其他gpio不可以透传,GPIO_REG[5:8]就不能透传。
透传的gpio，需要同时设置927和926的gpio寄存器，才能实现透传功能。




Table 1. GPIO Enable and Configuration（透传设置）：

引脚			设备					由927-->926正向透传			由926--->927反向透传
DESCRIPTION		DEVICE					FORWARD CHANNEL				BACK CHANNEL
GPIO3 			DS90UB927Q-Q1 			0x0F = 0x03 				0x0F = 0x05
GPIO3			DS90UB926/8Q-Q1 		0x1F = 0x05 				0x1F = 0x03

GPIO2			DS90UB927Q-Q1 			0x0E = 0x30 				0x0E = 0x50
GPIO2			DS90UB926/8Q-Q1 		0x1E = 0x50 				0x1E = 0x30	

GPIO1			DS90UB927Q-Q1			0x0E = 0x03 				0x0E = 0x05
GPIO1			DS90UB926/8Q-Q1 		0x1E = 0x05 				0x1E = 0x03

GPIO0			DS90UB927Q-Q1 			0x0D = 0x03 				0x0D = 0x05
GPIO0			DS90UB926/8Q-Q1 		0x1D = 0x05 				0x1D = 0x03








Table 2. GPIO_REG and GPIO Local Enable and Configuration(本地gpio设置)

DESCRIPTION 			REGISTER CONFIGURATION 				FUNCTION
GPIO_REG8				0x11 = 0x01 						Output, L
						0x11 = 0x09 						Output, H
						0x11 = 0x03 						Input, Read: 0x1D[0]

GPIO_REG7				0x10 = 0x01 						Output, L
						0x10 = 0x09							Output, H
						0x10 = 0x03 						Input, Read: 0x1C[7]
。。。



IDx 引脚的功能是 配置device I2C Address Select


PDB = H, device is enabled (normal operation)
PDB = L, device is powered down.

INTB	Interrupt
		INTB = H, normal
		INTB = L, Interrupt request
		Recommended pullup: 4.7 kΩ to VDDIO. 
		
		
		
FPD-Link interface (4 LVDS data channels + 1 LVDS Clock)		
		
		
7.3.12 Interrupt Pin (INTB)
1. On the DS90UB927Q-Q1 serializer, set register reg_0xC6[5] = 1 and 0xC6[0] = 1 (Table 5) to configure the
interrupt.
2. On the serializer, read from ISR register 0xC7 to arm the interrupt for the first time.
3. When INTB_IN on the deserializer (DS90UB926Q-Q1 or DS90UB928Q-Q1) is set LOW, the INTB pin on the
serializer also pulls low, indicating an interrupt condition.
4. The external controller detects INTB = LOW and reads the ISR register (Table 5) to determine the interrupt
source. Reading this register also clears and resets the interrupt.	
		
		
读取927寄存器0x0c，可查看927/926连接状态。		
the Link Detect Status is 0 (cable is not detected) on bit 0 of address 0x0C 	
		
		
		
		
serializer
927		----单LVDS输入，单FPD-Link输出， 没有 REM_INTB引脚
929		----单HDMI输入，单FPD-Link输出， 有   REM_INTB引脚
949		----单HDMI输入，双FPD-Link输出， 有   REM_INTB引脚




deserializer		
926		----单FPD-Link输入，单RGB输出
928		----单FPD-Link输入，单LVDS输出
948		----双FPD-Link输入，单LVDS输出
		
		

插入iPhone手机，并没有点击车机的carlife软件图标，
1.	create /dev/iap ok
2.	create /dev/mfi_eap_carlife ok


root@Gemini:/sys/bus/usb/drivers# ls
adk_skeleton   snd-usb-audio  usb-storage    usbhid
hub            usb            usbfs          uvcvideo
基本上,drivers/目录下面第一层的每个目录都算一个子系统,因为它们代表了一类设备


.hub本身就是两种,一种是普通的hub,一种是root hub.
对于普通hub,它完全可能也是和U盘一样,在某个时刻被你插入,然后这种情况下hub_probe被调用,
但是对于root hub就不需要这么多废话了,root hub肯定是有的,只要你有host controller,就一定会有root hub,
所以hub_probe()基本上是很自然的就被调用了,不用说非得等待某个插入事件的发生,没这个必要.

问题：系统启动的时候，root hub 的probe 是怎么被调用的？
--------------------- 
只要你有usb host controller,那么在usb host controller的驱动程序初始化的过程中,它就会调用hub_probe()来探测root hub,
不管你的host controller是ohci,uhci,还是ehci的接口.


 kernel/drivers/mtd/mtdcore.c 的 mtd_erase/mtd_write_oob/mtd_write API，
 
 
 
 
 
 
 
 
 
 
 
 
下载repo
curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo
chmod +x repo

export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'
 
 重新运行的命令 
? For TCC897X/TCC802X
$ mkdir Linux_platform
$ cd Linux_platform
$ repo init -u ssh://git.telechips.com/linux_ivi/manifest.git -m als_v2.5.2.xml
$ repo sync
$ poky/download.sh
 
 
 
    git config --global user.email "yuzp@zhonghongcarav.com.cn"
    git config --global user.name "yuzp"
 
如果以前下载过ALS，可以执行一次repo sync，在.repo/manifests/中就可看到als_v2.6.0.xml，再执行repo init -m als_v2.6.0.xml && repo sync即可下载v2.6.0版本 
 
 
 黄锐胜:
就是开机动画的size，你邮件有收到我昨天发的B511无UI报告吗？

BOSS-YU-BEYOND:
你们改动了哪些内容，我需要了解一下

BOSS-YU-BEYOND:
有的，那个pdf

黄锐胜:
对的，

黄锐胜:
开机动画的size是固定的，xboot将animation_logo.bin放到DRAM

黄锐胜:
播放的时候会传address和size进去

黄锐胜:
这个时候我将size改变

黄锐胜:
按照原理来没有修正的code，会出现IPC timeout的问题

 
 
 
 yuzp@zhos-sw:~/work/Linux_platform$ poky/download.sh
This may take a long time depending on your network environment.
Continue? (Y/n) => Y
Choose ALS version
  1. als_v2.5.0
  2. als_v2.5.1
  3. als_v2.5.2
select number(1-3) => 3
Do you want to download tools(ADT, buildtools), too? (Y/n) => Y
Start tools downloading...done
Start source mirror downloading...done
Start others downloading...done
yuzp@zhos-sw:~/work/Linux_platform$ 
 
 

 
 ~/works/Yocto/release/ALS/build/tcc8971-lcn-2.0a$ ls -1 tmp/deploy/images/tcc8971-lcn-2.0a/
automotive-linux-platform-image-tcc8971-lcn-2.0a.ext4
zImage-tcc8971-linux-lcn-2.0a.dtb
initramfs-telechips-image-tcc8971-lcn-2.0a.cpio.gz
modules-tcc8971-lcn-2.0a.tgz
tc-boot-tcc8971-lcn-2.0a.img
lk-tcc8971-lcn-2.0a.rom
~/works/Yocto/release/ALS/build/tcc8971-lcn-2.0a$



Choose ALS version
1. als_v2.5.0
2. als_v2.5.1
3. als_v2.5.2
select number(1-3) => 3

TCC8971 DEMO BOARD 目前的ALS version： als_v2.5.2，几个疑问点，以下功能怎么添加：
1.	目前编译出来桌面只有一个AV Play应用，可以在编译的时候选择更多应用吗
2.触摸屏功能怎么开启
3.倒车，音乐声音输出
4.aux in
5.蓝牙、WiFi
6。usb、sd卡
7.录音功能



export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./


内核source code 路径：
yuzp@zhos-sw:~/work/Linux_platform/build/tcc8971-lcn-2.0a/tmp/work-shared/tcc8971-lcn-2.0a/kernel-source$ ls
Z:\Linux_platform\build\tcc8971-lcn-2.0a\tmp\work\tcc8971_lcn_2.0a-telechips-linux-gnueabi\linux-telechips\3.18.24-r0\git

little kernel 源码路径：
Z:\Linux_platform\build\tcc8971-lcn-2.0a\tmp\work\cortexa7-neon-telechips-linux-gnueabi\lk-dt\1.0.0-r0\git



每次开启服务器，重新建立环境需要执行的动作：

 source buildtools/environment-setup-x86_64-pokysdk-linux
 
 source poky/als-build.sh
 
 export TEMPLATECONF=~/works/Yocto/release/ALS/poky/meta-telechips/template
 
 source poky/oe-init-build-env build/tcc8971-lcn-2.0a
 
  bitbake automotive-linux-platform-image
  
  
  
  
  设置交叉编译器环境：
  source ../adt/environment-setup-cortexa7-neon-telechips-linux-gnueabi
  
  终端输入arm-telechips-linux-gnueabi 按tab键 就会有补充
  
  
  
  adt安装默认路径：
  Enter target directory for SDK (default: /opt/poky-telechips-systemd/nodistro.0):
  
  
那么这个重复打印的原因是服务被重复开启了？	是的
那么这个重复打印的原因是服务被重复开启了？  是的

配置内核的命令：
bitbake -c menuconfig linux-telechips

这两条命令是干什么的？
bitbake -c cleanall linux-telechips
bitbake linux-telechips

生成镜像所在位置：
ls -1 tmp/deploy/images/tcc8971-lcn-2.0a/



Telechips Issue Management System：
https://tims.telechips.com:8443/secure/Dashboard.jspa

tims账号密码：
Username:
    yuzp@zhonghongcarav.com.cn 
password：
	zhonghong2018
	
注意
不要求图层名称以前缀开头meta-，但它是Yocto项目社区中普遍接受的标准。	
	
	
BitBake User Manual
		https://www.yoctoproject.org/docs/2.5.1/bitbake-user-manual/bitbake-user-manual.html#bitbake-user-manual-command
		
FTP_addr="rf.telechips.com"
FTP_user="customer"
FTP_pass="telecustomer12!"
DL_SOURCE_MIRROR_DIR="source-mirror"
ALS_VERSIONS="als_v2.5.0 als_v2.5.1 als_v2.5.2"


ncftp -u customer -p telecustomer12! rf.telechips.com


黄锐胜:
支持ISP需要满足这3个条件

一个partition，FAT32，扇区大小512



list_for_each_entry(d, &core_list, node)
/*记忆方法：core_list 是链表头，node是链表上的节点，d 是包含node成员的结构体。意思就是 从core_list链表头开始遍历每一个节点，就可以找到每一个d 结构体了*/



单独编译内核：
	bitbake linux-telechips

单独编译设备树：	
	
	
单独编译uboot：
	bitbake lk-dt
	
		
单独编译rootfs:
	
		
		
		
initramfs-telechips-image-tcc8971-lcn-2.0a.cpio.gz
modules-tcc8971-lcn-2.0a.tgz
 这两个是什么文件？	
 
  yocto-layer create layer_name创建一个新层
  
  
   3. 编译内核

         配置menuconfig指令：
        bitbake -c menuconfig -v linux-imx 
  
        单独编译kernel、模块、设备树
        bitbake -c compile -f -v linux-imx 
        bitbake linux-imx -c compile_kernelmodules -f -v    
        bitbake -c deploy -f -v linux-imx  

若要编译文件系统则用下面总指令
        bitbake core-image-minimal

         单独编译u-boot
        bitbake -c compile -f -v u-boot-imx
        bitbake -c deploy -f -v u-boot-imx
		

yocto project development manual		
https://www.yoctoproject.org/docs/2.2/dev-manual/dev-manual.html#new-recipe-writing-a-new-recipe		

Yocto Project Linux Kernel Development Manual 关键字：patch
https://www.yoctoproject.org/docs/2.0.1/kernel-dev/kernel-dev.html#applying-patches
		
bitbake 使用指南		
https://blog.csdn.net/lu_embedded/article/details/80634368


Yocto Bitbake的clean与cleanall以及cleansstate的区别
https://www.kancloud.cn/digest/yocto/138630

bitbake详解
https://blog.csdn.net/archer1991/article/details/62423014

bitbake语法
https://www.yoctoproject.org/docs/2.2/bitbake-user-manual/bitbake-user-manual.html#bitbake-user-manual-metadata


yocto的初始化脚本解释
https://blog.csdn.net/groundhappy/article/details/51307225


Yocto Project Development Environment
https://www.yoctoproject.org/docs/2.2/ref-manual/ref-manual.html#closer-look


Yocto Project Reference Manual 
https://www.yoctoproject.org/docs/2.2/ref-manual/ref-manual.html#usingpoky-debugging-tools-and-techniques



3.1.3. Setting a default value (?=)
3.1.4. Setting a weak default value (??=)
3.1.5. Immediate variable expansion (:=)
3.1.6. Appending (+=) and prepending (=+) With Spaces					,immediate effect during parsing
3.1.7. Appending (.=) and Prepending (=.) Without Spaces				,immediate effect during parsing
3.1.8. Appending and Prepending (Override Style Syntax)，Without Spaces	,effects are deferred until after parsing completes rather than being immediately applied.
		B_append 、C_prepend, 这些运算符与":=", ".=", "=.", "+=", and "=+"运算符的不同之处在于，它们的效果会延迟到解析完成后而不是立即应用。
3.1.9. Removal (Override Style Syntax)， Without Spaces
		FOO = "123 456 789 123456 123 456 123 456"
		FOO_remove = "123"
		FOO_remove = "456"
		FOO2 = "abc def ghi abcdef abc def abc def"
		FOO2_remove = "abc def"
		The variable FOO becomes "789 123456" and FOO2 becomes "ghi abcdef". 
3.1.10. Override Style Operation Advantages
		与 "+=" and "=+" 运算符相比，覆盖样式操作“_append”，“_ prepend”和“_remove”的一个优点是覆盖样式运算符提供了更有保证的操作。




例题：
     A = "1"
     A_append = "2"
     A_append = "3"
     A += "4"
     A .= "5"
答案：A becoming "1 4523".



		
配方（recipes）文件（后缀为 .bb）	
配方（recipes）的类文件（后缀为 .bbclass）
所有的配方文件都自动继承了 base.bbclass。base.bbclass 提供了大部分 bitbake 任务的默认实现。
一个配方文件可以继承多个类文件。
conf 目录包含编译系统的配置文件（后缀为 .conf）
BitBake允许通过include文件（.inc）和类文件（.bbclass）共享元数据。

BitBake允许通过include文件（.inc）和类文件（.bbclass）共享元数据。例如，假设您有一个常用功能，比如要在多个recipe之间共享的任务。在这种情况下，创建包含公共功能的.bbclass文件，然后在配方中使用inherit指令继承类是共享任务的常用方法。
BitBake提供的相应的机制，允许您在配方之间共享功能。 具体来说，机制包括include，inherit，INHERIT和require指令。

注意
inherit指令 继承类（.bbclass）的功能,该指令操作的对象是.bbclass文件。

include无法找到文件时， 该指令不会产生错误。因此，建议如果您要包含的文件存在，则应使用 require 而不是include。这样做可确保在找不到文件时产生错误。操作对象是.inc、.bb

require 指令。该指令的行为与include指令类似， 但如果无法找到要包含的文件，则BitBake会引发解析错误。操作对象是.inc、.bb

INHERIT 配置指令。仅在配置文件（.conf）中使用，与inherit指令一样操作的对象是.bbclass文件。
假设您需要继承abc.bbclass从配置文件调用的类文件，如下所示：

     INHERIT + =“abc”
	 
注意
因为.conf在BitBake执行期间首先解析文件，所以使用 INHERIT继承类有效地继承全局类（即所有配方）	 


require recipes-kernel/linux/linux-dtb.inc
require conf/machine/include/tune-cortexa7.inc

note：
require 文件的路径，相当于C语言中的include，也是有默认目录和当前目录 2种搜索路径的。
1.以 poky\meta\ 为顶层目录，即默认搜索目录。
2.以当前目录下搜索

每一个conf目录下的layer.conf文件中的变量都是全局变量

inherit kernel
note：
inherit 文件的路径，都是poky\meta\classes\目录下。

--------------------- 

Overrides and override-style 可以应用于任何shell函数，而不仅仅是 任务

软件包 B 在构建时可能依赖软件包 A 提供的头文件、库文件，也可能要使用软件包 C 生成的工具。我们必须在配方文件中用“DEPENDS”变量声明构建时的依赖关系。
recipe(.bb)、append(.bbappend)、configuration(.conf)、include(.inc) 和 class(.bbclass) 文件	


附加文件(Append Files)

附加文件是具有.bbappend文件扩展名的文件，用于扩展或覆盖现有配方文件中的信息。
BitBake期望每个附加文件具有相应的配方文件。此外，附加文件和相应的配方文件必须使用相同的根文件名，只能在使用的文件类型后缀方面有所不同（例如formfactor_0.0.bb和formfactor_0.0.bbappend）。
附加文件中的信息将会扩展或覆盖匹配的的配方文件中的信息。
在命名附加文件时，可以使用通配符（％）来匹配配方文件名称。例如，假设您有一个如下的追加文件：
　　busybox_1.21.％.bbappend
该附加文件将匹配任何busybox_1.21.x.bb版本的配方文件。因此，附加文件将匹配以下配方名称：
　　busybox_1.21.1.bb
　　busybox_1.21.2.bb
　　busybox_1.21.3.bb
如果busybox的配方更新为busybox_1.3.0.bb，则附加文件名称将不匹配。但是，如果你命名了附加文件为busybox_1.％.bbappend，那么你将会依然匹配busybox_1.3.0.bb文件。
在通常情况下，您可以将附加文件命名为busybox _％.bbappend。这样简单，完全独立于版本。
--------------------- 
作者：勇敢的心2013 
来源：CSDN 
原文：https://blog.csdn.net/archer1991/article/details/62423014 
版权声明：本文为博主原创文章，转载请附上博文链接！


linux-telechips                                   :3.18.24-r0                          
linuxdoc-tools-native                              :0.9.69-r0                          
lk                                                  :1.0.0-r0                          
lk-dt                                               :1.0.0-r0                          
lk-tcc                                              :1.0.0-r0                          


u-boot-mkimage                                   1:2017.11-r0                          
u-boot-mkimage-native                            1:2017.11-r0                  


 $ {PN} / $ {EXTENDPE} $ {PV} - $ {PR}
 foo / 1.3.0-r0
 
 
　　PN：配方名称	foo
　　PV：配方版本	1.3.0
　　PR：配方修订版 	r0
	recipe name (PN) and version (PV)


 
install -d ${D}${bindir}
| xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
| D:/opt/disk3/yuzp/test2/als_v2.5.2_2/build/tcc8971-lcn-2.0a/tmp/work/cortexa7-neon-telechips-linux-gnueabi/yuzp-demo/0.1-r0/image
| bindir:/usr/bin
{libdir}:/usr/lib
{includedir}:/usr/include


在recipes中加入打印信息，有两种方式
    一种是Python形式，该形式可在console上打印出来: bb.plain, bb.note, bb.warn, bb.error, bb.fatal, bb.debug
    另一种是bash形式，该形式会在temp目录下的log中包含，需要inherit logging(base.bbclass会包含，通常不需要特意添加): bbplain, bbnote, bbwarn, bberror, bbfatal, bbdebug
		 bbnote "1111111111111111"			//不会输出到console
		bbplain "222222222222222222"		//白色字体 输出到console
		 bbwarn "D:${D}"					//黄色的警告字体 输出到console
		 bberror "binder:${bindir}"			//报错，不会继续往下编译
	包依赖中带有-native的表示这些包被host使用。
    比如bb文件中包含如下语句： DEPENDS += "lzop-native bc-native" 表示lzop和bc将会被host使用。
	
	


Yocto tips (5): Yocto如何更改source code的下载与git clone地址
https://blog.csdn.net/sy373466062/article/details/50363537


yocto  .bb file SRC_URI
https://community.nxp.com/thread/392020

Yocto更改源码的获取位置与git clone 地址
https://blog.csdn.net/yangteng0210/article/details/82022938?utm_source=blogxgwz3


xargs 命令


git commit 有弹框进入vim，填写信息 然后ctrl+o,回车保存，再ctrl+x退出

git查看远程仓库地址命令
git remote -v

file：//-从本地获取文件，这些文件通常是元数据附带的文件。其路径相对于FILESPATH变量。
因此，构建系统按顺序从配方文件（.bb）或附加文件（.bbappend）所在的目录的子目录中搜索：


./meta-telechips/meta-bsp/conf/machine/tcc897x.inc:39:KBUILD_DEFCONFIG ??= "tcc897x_linux_avn_lcn_defconfig"

./meta-telechips/meta-bsp/conf/machine/tcc8971-lcn-2.0a.conf:9:KBUILD_DEFCONFIG ??= "${@bb.utils.contains('INVITE_PLATFORM', 'fastboot', 'tcc897x_linux_avn_lcn2_reduce_defconfig', 'tcc897x_linux_avn_lcn2_defconfig', d)}"



			bitbake -C compile <target>
            注意：这里使用了-C，表示编译该task后，再编译所有的task。等效于
                bitbake -c compile <target>
                bitbake <target>
				
				
				

PROVIDES 用于提供配方的别名。

以配方文件libav_0.8.11.bb为例，libav_0.8.11.bb中的PROVIDES语句如下：

PROVIDES + =“libpostproc”

该PROVIDES语句使得“libav”配方也被称为“libpostproc”。



DEPENDS		列出配方的构建时的依赖项（即其他配方文件）。
RDEPENDS	列出包的运行时依赖关系（即其他程序包）


tmp/work/tcc8971_lcn_2.0a-telechips-linux-gnueabi/linux-telechips/3.18.24-r0/temp/log.task_order	这个文件显示了编译 linux-yocto 执行的task 以及 task 的执行顺序。


bitbake automotive-linux-platform-image -c cleansstate
bitbake linux-telechips -c cleansstate
bitbake lk-dt -c cleansstate

bitbake initramfs-telechips-image -c cleansstate
bitbake telechips-image-update -c cleansstate
bitbake update-rootfs -c cleansstate
bitbake tc-updater -c cleansstate

bitbake -s |grep rootfs
bitbake customize-rootfs -c cleansstate
bitbake update-rootfs -c cleansstate




root@telechips-tcc8031:~# tc-write-misc
write 'boot-recovery' to /dev/disk/by-partlabel/misc finished
root@telechips-tcc8031:~#

/dev/disk/by-partlabel		这个地址可以查看分区

 local.conf中定义的变量都是全局变量
BitBake 是一个执行 python 和 shell 脚本的引擎；
BitBake 使用的 5 种文件类型（.bb，.bbclass，.bbappend，.conf 和 include 文件）；


构建时依赖 和 运行时依赖
 build-time dependencies, which are required when the software is built; 
 runtime dependencies, which are required to be installed on the target in order for the software to run. 


FILESPATH在查找file://配方中每个URI 指定的文件和补丁时，按指定的顺序 搜索每个目录 。
 The default value for the FILESPATH variable is defined in the base.bbclass class found in meta/classes in the Source Directory:

     FILESPATH = "${@base_set_filespath(["${FILE_DIRNAME}/${BP}", \
        "${FILE_DIRNAME}/${BPN}", "${FILE_DIRNAME}/files"], d)}"
                    



If the first recipe is named a_1.1.bb, then the PN variable will be set to “a”, and the PV variable will be set to 1.1.
a recipe called "something_1.2.3.bb" would set PN to "something" and PV to "1.2.3".




BBPATH is used to search for configuration and class files under the conf and classes directories.
BBFILES is used to locate both recipe and recipe append files (.bb and .bbappend). 
BBPATH用于分别搜索conf和classes 目录下的配置和类文件 。 
BBFILES用于定位配方和配方附加文件（.bb和.bbappend）。


The PACKAGES variable lists the packages generated by a recipe.
The FILES variable lists the files and directories that are placed in a package.
The DEPENDS is a list of recipe names.
 example:

     FILES_${PN} += "${bindir}/mydir1 ${bindir}/mydir2/myfile"
	 
FILES :指定需要放入包中的目录或文件的列表。
使用FILES变量时，必须与生成包的包名结合使用。然后提供一个空格分隔的文件或路径列表，用于标识要包含在生成包中的文件。例如：

FILES _ $ {PN} + =“$ {bindir} / mydir1 / $ {bindir} / mydir2 / myfile”


The standard BitBake behavior in most cases is: do_fetch, do_unpack, do_patch, do_configure, do_compile, do_install, do_package, do_package_write_*, and do_build.


do_install() {
    install -d ${D}${libdir} ${D}${includedir}
    install -m 0644 ${S}/testlib1.so ${D}${libdir}
    install -m 0644 ${S}/testlib2.so ${D}${libdir}
    cp -ap ${S}/testlib.h ${D}${includedir}
	bbplain "[-yuzp-]{libdir}:${libdir}"
	bbplain "[-yuzp-]{includedir}:${includedir}"
}
//这个函数，是创建${D}${libdir} ${D}${includedir}目录，并向目录中分别拷贝文件。


PACKAGES = "${PN}"	//这句话的作用是指定包（packages)的名称。

FILES_${PN} += " \
    ${libdir}/*.so \
    ${includedir}/*.h \
"
//这句话是 指定需要放入包中的文件的列表。
//FILES 相对路径是${D}目录，即$ {WORKDIR} / image 下的目录及文件

${WORKDIR}:	$ {TMPDIR} / work / $ {MULTIMACH_TARGET_SYS} / $ {PN} / $ {EXTENDPE} $ {PV} - $ {PR}
tmp\work\cortexa7-neon-telechips-linux-gnueabi\mytest\1.0.0-r0

${S}:	${WORKDIR} / $ {PN} - $ {PV}
${D}:	${WORKDIR} / image
The list of packages to be created from the recipe. The default value is the following:
 ${PN}-dbg ${PN}-staticdev ${PN}-dev ${PN}-doc ${PN}-locale ${PACKAGE_BEFORE_PN} ${PN}

 
 
oe-pkgdata-util list-pkgs [pattern]: Lists all packages that have been built, optionally limiting the match to packages that match pattern.
你可以使用标准*和？通配符通配符作为包名称和路径的一部分。
oe-pkgdata-util list-pkgs 				//查看所有package
oe-pkgdata-util list-pkgs helloworld	//查看是否有这个package





oe-pkgdata-util list-pkg-files package ...: Lists the files and directories contained in the given packages.
$oe-pkgdata-util list-pkg-files testlib	//查看package中文件和目录的列表
testlib:
	/usr/include/testlib.h
	/usr/lib/testlib1.so
	/usr/lib/testlib2.so


查看包内容的另一种方法是查看 如下所示：
${WORKDIR}/packages-split directory of the recipe that generates the package. This directory is created by the do_package task
If you want to inspect the ${WORKDIR}/packages-split directory, make sure that rm_work is not enabled when you build the recipe.


oe-pkgdata-util lookup-recipe package ...: Lists the name of the recipes that produce the given packages.
$oe-pkgdata-util lookup-recipe testlib	//查看package是属于哪个recipe





构建过程中的这一步包含三个任务：
do_configure：

do_compile： 一旦配置任务满足，BitBake就会使用do_compile 任务编译源代码 。编译发生在B 变量指向的目录中 。意识到B目录，默认情况下，在相同 S 目录下。

do_install： 编译完成后，BitBake执行 do_install 任务。此任务从B 目录复制文件并将它们放在D 变量指向的保留区域中 。


The TOPDIR variable points to the Build Directory.


"Package Feeds"目录：
tmp\deploy\rpm\cortexa7_neon\



STAMP 设置在meta/conf/bitbake.conf：

     STAMP =“$ {STAMPS_DIR} / $ {MULTIMACH_TARGET_SYS} / $ {PN} / $ {EXTENDPE} $ {PV}  -  $ {PR}”



























/*-------------------------------------------------------------------------------------
如 meta-tutorial/classes/mybuild.bbclass：
addtask build
mybuild_do_build () {
 
  echo "running mybuild_do_build."
 
}
 
EXPORT_FUNCTIONS do_build

在 base.class 中，我们添加了一个 build task，它也是一个简单的 shell 函数。mybuild_do 前缀的依据是 class 中 task 定义的规范 classname_do_functionname。
EXPORT_FUNCTIONS 使该 build 函数可被这个 class 的使用者使用，如果不添加这行，则它不会覆盖 base class 中的 build 函数。
--------------------------------------------------------------------------------------------------------------------------------------------------------*/


do_set_kernel_defconfig() {
	# 把 arch/arm/configs/tcc897x_linux_avn_lcn2_reduce_defconfig 拷贝为 defconfig(所在目录 tmp\work\tcc8971_lcn_2.0a-telechips-linux-gnueabi\linux-telechips\3.18.24-r0\ )
	#	
	if [ -n "${KBUILD_DEFCONFIG}" ]; then
		bbplain "[-yuzp-]linux-telechips.inc WORKDIR:${WORKDIR}"
		if [ -f "${S}/arch/${ARCH}/configs/${KBUILD_DEFCONFIG}" ]; then
			if [ -f "${WORKDIR}/defconfig" ]; then
			    bbnote "defconfig detected in WORKDIR. ${KBUILD_DEFCONFIG} skipped"
			else
				cp -f ${S}/arch/${ARCH}/configs/${KBUILD_DEFCONFIG} ${WORKDIR}/defconfig
			fi
		else
			bbfatal "A KBUILD_DECONFIG '${KBUILD_DEFCONFIG}' was specified, but not present in the source tree"
		fi
	fi
}



gst-launch-1.0 filesrc location=/run/media/sda1/http_and_raw_h264_800x416_30sec.bin ! h264parse ! omxh264dec ! v4l2sink

gst-launch-1.0 playbin uri=file:///run/media/sda1/http_and_raw_h264_800x416_30sec.bin video-sink=v4l2sink 










tcc8974 代码管理路径：
环境，	git@githost:telechips-tcc8971.git
kernel	git@githost:telechips-tcc8971-kernel.git
uboot	git@githost:telechips-tcc8971-uboot.git










比较实用的应用
$ ls | xargs -t -i mv {} {}.bak
-i 选项告诉 xargs 用每项的名称替换 {}。

find ./ -nama ".git"|xargs rm -rf


cat /proc/interrupts

echo 1 > /proc/sys/kernel/printk




$(MAKEFILE_LIST) 会返回最近使用的Makefile文件（如果使用了include 包含了一个Makefile文件那么返回就是这个被include 包含的Makefile文件的路径，如果没有使用include 那么返回的是正在使用的Makefile文件所在的绝对路径）

lastword这个函数表示提取最后一个MAKEFILE_LIST列表里的最后一个元素。元素与元素之间是以空格符分开。 $(lastword $(MAKEFILE_LIST)) 表示提取最后一个Makefile
--------------------- 

















CarLife 做 MFI 认证需要通过 IAP2 的认证 

百度 CarLife 手机和车机采用的是 EAP 连接， 
而 CarPlay 是通过 NCM 端口来传输数据的 

AOA是什么？






高清屏项目调试触摸屏出现的现象：
1.CPU占用率高。 当触摸时，CPU占用率瞬间会升高到70%左右
2.i2c不稳定。	读到的数据，时常会出现校验和错误


I2C scl高电平期间, sda读取数据
	scl低电平期间，sda发送数据
所有的时钟脉冲包括ACK信号对应的时钟脉冲都是由master产生的。
        ACK信号：发送者在ACK时钟脉冲期间释放SDA线，接收者可以将SDA拉低并在时钟信号为高时保持低电平。

        NACK信号：当在第9个时钟脉冲的时候SDA线保持高电平，就被定义为NACK信号。Master要么产生STOP条件来放弃这次传输，或者重复START条件来发起一个新的开始。
--------------------- 

jiffies 的时间单位：
jiffies的计数增加，是根据HZ的值面而变化的。
如果 HZ=100， 1个jiffies = 10 ms
如果 HZ=1000, 1个jiffies = 1 ms 

root@telechips-tcc8971-lcn-2:/opt/data# ./mmc cid read /sys/devices/76020000.sdhc/mmc_host/mmc1/mmc1:59b4
type: 'SD'
manufacturer: 'Unlisted' ''
product: 'SCI  ' 0.0
serial: 0x00000000
manfacturing date: 2017 mar
root@telechips-tcc8971-lcn-2:/opt/data# 

serial 同一个厂家的serial是一样的，不同厂家的serial可能会出现一样。所以需要应用上加上 厂商名称、品牌等信息做区分。

bInterval:	端点数据传输的访问时间间隔。对于全速/低速的中断端点，取值范围为 1~255，对于高速中断端点，取值范围为1~16
			这个值只有在端点类型是中断类型时才起作用，它是端点中断请求的间隔时间，以毫秒为单位。
			
			
	_ _u8 bInterval;//轮询数据传送端点的时间间隔
	                       //对于批量传送的端点以及控制传送的端点，此域忽略
	                    //对于同步传送的端点，此域必须为1			
			
			
			
			
一、USB 描述符：（存在于USB 的E2PROM里面）

1、  设备描述符：struct usb_device_descriptor

2、  配置描述符：struct usb_config_descriptor

3、  接口描述符：struct usb_interface_descriptor

4、  端点描述符：struct usb_endpoint_descriptor			




二、USB的传输方式：
USB_ENDPOINT_XFER_CONTROL（控制传输）（control）
       用于配置设备、获取设备信息、发送命令或者获取设备的状态报告
	   
USB_ENDPOINT_XFER_INT（中断传输）（interrupt）
       （这里说的中断和硬件上下文的中断不一样，它不是设备主动发送一个中断请求，而是主控制器在保证不大于某个时间间隔interval内安排的一次数据传输）例如USB鼠标、USB键盘
	   
USB_ENDPOINT_XFER_BULK（批量传输）（bulk）
       用于大量数据的可靠传输，如果总线上的空间不足以发送整个批量包，它会被分割成多个包传输。没有固定的传输速率，例如usb打印机、扫描仪、U盘等，对应的端点就叫批量端点
	   
USB_ENDPOINT_XFER_ISOC（等时传输）（isochronous）
       大量数据的不可靠传输，不保证数据的到达，对实时性要求很高， 例如音频、视频等设备（USB摄像头、USB话筒），对应的端点就叫等时端点		
	   
	   
	   
	   
git 公钥和私钥 ssh
https://git-scm.com/book/zh/v2/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5


下面是设备树中节点属性status的处理代码，位于内核的drivers/of/base.c中

static bool __of_device_is_available(const struct device_node *device)
{
    const char *status;
    int statlen;

    if (!device)
        return false;

    status = __of_get_property(device, "status", &statlen);
    if (status == NULL)
        return true; //默认为使能

    if (statlen > 0) {
        if (!strcmp(status, "okay") || !strcmp(status, "ok")) //ok和okay都可以
            return true;
    }
    //表中的fail和fail-sss没做具体处理
    return false;
}
--------------------- 













查看某个文件的提交历史
git log filename

查看某个文件夹的提交历史 ？


查看某个历史版本文件的修改内容
git show commit_id filename
	   


如何制作Ext4文件系统镜像
https://blog.csdn.net/q123456789098/article/details/51912015
	   
mount -t ext4 -o loop test.ext4 mount_test

mkuserimg.sh文件路径：Android sdk中的 out/host/linux-x86/bin/mkuserimg.sh


mkuserimg.sh [-s] SRC_DIR OUTPUT_FILE EXT_VARIANT MOUNT_POINT SIZE
./mkuserimg.sh -s /some/directory/with/files ./factoryfs_custom.img ext4 ./temp 512M








meta/classes/image-live.bbclass:46:ROOTFS ?= "${IMGDEPLOYDIR}/${IMAGE_LINK_NAME}.ext4"
meta/classes/image-live.bbclass:48:IMAGE_TYPEDEP_live = "ext4"
meta/classes/image-live.bbclass:49:IMAGE_TYPEDEP_iso = "ext4"
meta/classes/image-live.bbclass:50:IMAGE_TYPEDEP_hddimg = "ext4"
meta/classes/image-vm.bbclass:35:VM_ROOTFS_TYPE ?= "ext4"



automotive-linux-platform-image-tcc8971-lcn-2.0a.ext4

ROOTFS ?= "${IMGDEPLOYDIR}/${IMAGE_LINK_NAME}.ext4"
IMAGE_LINK_NAME = "${IMAGE_BASENAME}-${MACHINE}"
${IMAGE_BASENAME}  --> IMAGE_BASENAME = "${PN}" --> automotive-linux-platform-image
${MACHINE}  --> tcc8971-lcn-2.0a



ROOTFS ?= "${IMGDEPLOYDIR}/${IMAGE_LINK_NAME}.${VM_ROOTFS_TYPE}"





poky/meta-telechips/meta-update/recipes-applications/images/automotive-linux-platform-image.bbappend			就是bootloader、dtb、kernel、rootfs 的拷贝到update文件夹 及重命名



interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
		 <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
		 
*第一个cell表示中断类型，0代表SPI interrupts，1代表PPI interrupts
*第二个cell表示中断号码，SPI interrupts的中断号范围是0 ~ 987，而PPI
*interrupts的中断号范围是0 ~ 15
*第三个cell表示触发方式，它有4个值，分别为1，2，4，8
*1表示上升沿触发，2表示下降沿触发
*4表示高电平触发，8表示低电平触发. 
--------------------- 

gpio-controller;//表明自己的身份为gpio控制器
#gpio-cells = <2>;
//第一个cell表示gpio号，第二个cell表示gpio默认电平
interrupt-controller;//表明自己的身份为中断控制器
#interrupt-cells = <2>;
//第一个cell表示中断号，第二个cell表示中断触发方式 
--------------------- 
	 
	 
	 
	 
	 
Linux 4.x 之Gpio分析（一）Gpiolib库1	 
https://blog.csdn.net/zmnqazqaz/article/details/78228180#3%E4%BB%A3%E7%A0%81





[Unit] [Service] [Install]
https://www.jianshu.com/p/a9d61f5be35f
https://wenku.baidu.com/view/a3d2f911f705cc17552709f4.html
https://blog.csdn.net/cug_heshun2013/article/details/79632811






echo "Hello, Systemd! @ $(date)" > /home/test.log

echo w 0x0e 0x30 > ./devices/platform/i2c-gpio.0/i2c-0/0-001a/register_947

echo w 0x1e 0x90 > ./devices/platform/i2c-gpio.0/i2c-0/0-001a/register_948

echo r 0x0e > ./devices/platform/i2c-gpio.0/i2c-0/0-001a/register_947





top -m 3 -d 1



1. struct resouse 实际来源于 .dts中设备节点reg、interrupt属性。

2. /根节点下的所有子节点，内核解析为platform总线。
	platform总线下的节点，内核解析为某些真实的总线如i2c，spi，usb等。
	platform总线的节点名字带有“simpile-bus"等字，则其子节点也被解析为platform总线。
	
3.	

TP中A/B协议的区别:
 B协议又称为slot协议,slot直译为位置、槽，有两层含义。一层是位置，还有一层是容器。在Input子系统中。它扮演的就是这两个角色。
 它产生于这样一个背景：
      假设从Device获取的当前数据与上一个数据同样，我们有必要再上报当前数据吗？
	  假设我们无论两次数据是否一致都上报。那就是A协议；
	  假设我们选择不上报。那么既然须要比較。总须要把上一次数据存起来吧。slot就是做这个事情的，显然这就是Slot(B)协议。
	  
	  
ESD(Electro-Static discharge),我们常说防止ESD就是这个意思。就是静电防护	  



一般用户态传递参数是通过main函数，第一个参数表示args个数，即argc，第二个参数表示具体的参数

在kernel态，无法通过这样的方式传递参数，一般使用宏module_param的方式，步骤如下：
1.使用module_param指定模块的参数
2.加载driver时给模块传递参数
--------------------- 


#define module_param(name, type, perm)                \
    module_param_named(name, name, type, perm)

通过命令"modinfo -p ${modulename}"可以得知一个模块有哪些参数可以使用。
同时，对于已经加载到内核里的模块，它们的模块参数会列举在/sys/module/${modulename}/parameters/目录下面，
可以使用"echo -n ${value} > /sys/module/$ {modulename}/parameters/${parm}"命令修改。 


linux标准log管理：
cat /var/log/messages
tail -F /var/log/messages


systemd service notify  simple	区别?


val是phandle或linux,phandle值的指针。
np->phandle = be32_to_cpup(val);	//把val指针保存到phandle变量中


把runtime.cfg文件读出来修改，然后再写回去
dd if=/dev/mtdblock16 of=/media/flash/nvm/run.cfg
dd if=/media/flash/nvm/run.cfg of=/dev/mtdblock16


每一个irq_domain都对应一个irq_chip，irq_chip是kernel对中断控制器的软件抽象




root@Gemini:/tmp/sp/usr/local# cat /proc/cmdline 
console=ttyS0,115200 root=/dev/blockrom8 rootfstype=squashfs init=/init loglevel=7 printk.time=1 lpj=8396800 mtdparts=sp_nand.0:128k(nand_header),128k(xboot1),1m(uboot1),2m(uboot2),512k(env),512k(env_redund),8m(ecos),6m(kernel),5760k(rootfs),54144k(spsdk),110m(spapp),20m(nvm),128k(pq),4m(logo),128k(tcon),2m(iop_car),1m(runtime_cfg),128k(vi),5m(isp_logo),256k(vendordata),20m(pat_logo),128k(version_info),256k(vd_restore),5376k(anm_logo),267m(userdata) res_arm926_addr=0 res_arm926_size=0x7400000 res_linux_addr=0x200000 res_linux_size=0xe00000 res_iop_addr=0x1000000 res_iop_size=0x100000 res_display_addr=0x7400000 res_display_size=0x0 res_rtcfg_addr=0x7400000 res_rtcfg_size=0x100000 res_vd_addr=0x7480000 res_vd_size=0x80000 mem=487M@0x0 res_chunkmem_addr=0x1e700000 res_chunkmem_size=0x1900000 vmalloc=320M  uuid=0000000000000001



interrupts =  <1  28  0  4>,  <1  28  1  4>;

    <1 28 0 4>

    1：是子控制器

    28：主中断是28

    0：子中断的硬件中断号为0

    4：为高电平触发

    定位到INT_RXD0中断源

    <1 28 1 4>

    1：是子控制器

    28：主中断是28

    1：子中断的硬件中断号为1

    4：为高电平触发
--------------------- 
作者：qq_33513098 
来源：CSDN 
原文：https://blog.csdn.net/qq_33513098/article/details/88723282 
版权声明：本文为博主原创文章，转载请附上博文链接！


为什么插入苹果手机,车机usb是做device呢?



struct samsung_pin_bank_data {
与
struct samsung_pin_bank {
的区别？分别是描述什么的？



若干个引脚还可以组成一个pin group，形成特定的功能。例如pin number是{ 0, 8, 16, 24 }这四个引脚组合形成一个pin group，提供SPI的功能。

为何又有function这个概念呢？什么是function呢？SPI是function，I2C也是一个function，当然GPIO也是一个function。一个function有可能对应一组或者多组pin。

samsung_gpiolib_register函数就是把各个bank代表的gpio chip注册到GPIO subsystem中

samsung_pinctrl_register函数的主要功能是将本pin controller注册到pin control subsystem。


 [root@localhost ntop-4.0.1]# lsusb

//总线号      设备号          厂商ID(vid:pid)

Bus 001      Device 001:   ID 1d6b:0001

struct pinctrl_desc *ctrldesc		//描述设备树中的pinctrl
struct pinctrl_pin_desc *pindesc,	//描述设备树pinctrl中单个pin 脚。
struct samsung_pin_bank *bank;		//描述单个bank 

struct pinctrl_dev *pctldev;				//pinctrl 设备
struct samsung_pinctrl_drv_data *drvdata	//将作为私有数据赋值给pctldev

pinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev, void *driver_data)
{ 
	pctldev->desc = pctldesc;
	pctldev->driver_data = driver_data;
	pctldev->dev = dev;
}


你说错了 正常开机是只上ACC    一起上B+和ACC 这个操作只有第一次装车才会有   
正常开机是上ACC   正常关机是掉ACC   


root@Gemini:/sys/bus/usb/devices# ls 
1-0:1.0  2-1      4-0:1.0  6-0:1.0  usb2     usb4     usb6
2-0:1.0  3-0:1.0  5-0:1.0  usb1     usb3     usb5
root@Gemini:/sys/bus/usb/devices# 

1-0:1.0就是interface的目录，表示root hub1-port0上的configuration1的interface0,

命名规则是：roothub-port:configuration.interface.









usb是从usb1开始并非其他的像mmc i2c bus是从0开始。任何usb host controller都是与hub同时存在，这里也不例外，1-0就是
hub,1-1:说明是在1 port上的，1-1：1.0也就是1 port上第一个接口。

比如电脑主机上前面的2个usb port其实都是一个hub下面的，我的电脑主机usb1上的第5个端口挂了个hub,同时手机插在该hub上的第4个port，那么节点该是啥样？1-5.4：1. ？这些就是linux usb节点规范。

下面是我的主机给出的信息：
root@hd:~$ ls /sys/bus/usb/devices/1-5.4/
1-5.4:1.0/           avoid_reset_quirk    bMaxPacketSize0      dev                  ltm_capable          removable            version
1-5.4:1.1/           bcdDevice            bMaxPower            devnum               manufacturer         remove               
1-5.4:1.2/           bConfigurationValue  bNumConfigurations   devpath              maxchild             serial               
1-5.4:1.3/           bDeviceClass         bNumInterfaces       driver/              port/                speed                
1-5.4:1.4/           bDeviceProtocol      busnum               ep_00/               power/               subsystem/           
1-5.4:1.5/           bDeviceSubClass      configuration        idProduct            product              uevent               
authorized           bmAttributes         descriptors          idVendor             quirks               urbnum    
--------------------- 
作者：eqwewr 
来源：CSDN 
原文：https://blog.csdn.net/linux_devices_driver/article/details/39482363 
版权声明：本文为博主原创文章，转载请附上博文链接！




/**
 * devm_pinctrl_register() - Resource managed version of pinctrl_register().
 * @dev: parent device for this pin controller
 * @pctldesc: descriptor for this pin controller
 * @driver_data: private pin controller data for this pin controller
 */
 struct pinctrl_dev *devm_pinctrl_register(struct device *dev, struct pinctrl_desc *pctldesc, void *driver_data)
 
 
 
  ddr3 1600什么意思
是指它的频率是1600MHz吗，它的倍频是多少，外频呢，那些pc1600又是什么呢？ 

我告诉你：
1, 倍频和外频是针对处理器的（主频＝外频X倍频），和内存无关。
2,内存涉及两个：第一是实际工作频率，第二是等效频率。
DDR3 1600的实际频率是400MHZ，等效频率是1600MHZ。具体解释：
DDR已经有1、2、3代了，不过实质没有变。
DDR内存是取代SDR内存的，因此面世的时候，性能是比较SDR来说的。DDR，第一个D是Double的意思，即同一周期内，数据传输两次（SDR只有一次）。因此，DDR内存的实际频率X2，就是“等效频率”（即同样性能下，SDR需要多少实际频率）。
DDR266实际频率133MHZ，DDR333实际频率166MHZ，DDR400实际频率200MHZ
DDR2 533实际频率266.5MHZ，DDR2 667实际频率333.5MHZ，DDR2 800实际频率400MHZ
DDR2 1066实际频率533MHZ，DDR3 1066实际频率533MHZ
DDR3 1333实际频率666.5MHZ，DDR3 1600实际频率800MHZ 





调试总结：
1. 中断处理函数中不能加太多打印，会延长中断处理时间，中断处理不及时。

2. 抓波形，查看并分析波形。
	a. 中断处理是否及时。终端信号后是否立马有i2c读操作	
	b. 是否有漏中断、中断叠加（中断还没处理完另一个中断又来了）

3. 清中断的时机。
	a. 中断函数中立即清中断，再读i2c数据，处理中断。
	b. 中断函数中读i2c数据后，清中断，处理中断。
	b. 中断函数中读i2c数据后，处理完中断，清中断
	
	
freescal 设备树分析：
设备树中：arch\arm\boot\dts\imx6q.dtsi中			iomuxc: iomuxc@20e0000 {compatible = "fsl,imx6q-iomuxc";};
kernel中：drivers\pinctrl\freescale\pinctrl-imx6q.c 中 .compatible = "fsl,imx6q-iomuxc",




三、Linux系统中USB设备的加载与卸载

当把一个USB设备插入到一个USB HUB的某个端口时，集中器就会检测到设备的接入，从而在下一次受到主机通过中断交互查询时就会向其报告。集中器的端口在没有设备接入时都处于关闭状态，插入设备之后也不会自动打开，必须由主机通过控制交互发出命令予以打开。所以，在得到集中器的报告之后，主机的USB驱动程序就会为新插入的设备调度若干个控制交互，并向集中器发出打开这个端口的命令，这样新插入的设备就会出现在USB总线上了，并为该设备分配唯一的地址。

HUB驱动程序调用函数usb_connect(struct usb_device *dev)和usb_new_device(struct usb_device *dev)解析设备的各种描述符信息，分配资源，并与相应的设备驱动程序建立联系。

函数usb_new_device主要完成以下工作：

1.调用usb_set_address把新分配的设备地址传送给设备。

2.调用usb_get_descriptor获得设备的设备描述符，得到设备端点的包的最大长度，接下来的控制传输按这个数据包最大长度进行。

3.调用usb_get_configuration得到设备的所有配置描述符、接口描述符和端点描述符信息。

4.调用usb_set_configuration激活当前的配置作为默认工作配置。

5.在目录“proc/bus/usb”中为设备创建节点。

6.在USB子系统中，通过函数usb_find_drivers和usb_find_interface_driver，为设备的每一个接口寻找相应的驱动程序，驱动程序对接口进行配置并为它们分配所需的资源。当每个接口被成功驱动后，此设备就能正常工作了。

设备拔下时，与之相联的集线器首先检测到设备的拔下信号，通过中断传输将信息传送给集线器的驱动，集线器的驱动先验证设备是否被拔下，如果是则调用usb_disconnect(struct usb_device **pdev)进行处理。设备断开后，USB系统找到设备当前活动配置的每个接口的驱动程序，调用它们提供的disconnect接口函数，中断它们与各个接口的数据传输操作，释放它们为每个接口分配的资源。如果此设备是集线器，则递归调用usb_disconnect来处理它的子设备，释放设备地址，通过usbdevfs_remove_device函数释放给设备创建的文件节点，通过usb_free_dev释放USBD给设备分配的资源。


Usb Composite Device（一般称为复合设备）
USB Accessory（USB 配件）

2.1 USB Accessory底层驱动的设计实现
2.1.1 什么是USB composite设备

因为目前的Android平台设备在与PC进行连接时，大都表现为USB Composite设备，因此这里有必要对USB Composite设备进行一下介绍。
什么是USB Composite设备呢？对于大部分USB Device设备来说，它仅仅只有一个功能，比如大部分U盘，单个的USB鼠标等；但是也有些USB设备不止实现一个功能，比如某些USB上网卡有无线上网的功能，同时还有U盘存储的功能；又比如有的鼠标和键盘二合一设备，它只有一个USB接口，却同时支持了鼠标和键盘两个功能。

这种一个USB接口扩展出多个设备功能的实现方法有两种，一种是在设备外部或内部加Hub扩展；另一种就是以Usb Composite Device方式实现（一般称为复合设备）。

复合设备其实只是一个USB设备，只有一个USB设备地址，它实现多个功能的原因主要在于它扩展实现了多个USB接口，每个接口具有不同的设备类型。
这里涉及到USB协议的一些知识，有兴趣的读者可以去找资料了解一下，这里我们重点是要知道Android下采用了USB Composite Device这种方式来实现一个USB口的情况下扩展出多个功能设备，这种情况下一个USB接口（Interface）便对应一种类型的功能设备，需要实现与之对应的功能驱动。




举个例子：
当我们手机使用OTG线接U盘时，一般手机OTG线，手机端时mini头，里面的ID被接到了GND，另一端是正常USB的母座，只有4pin，没有ID脚，相当于悬空。手机就是设备A，因为ID脚被连到了GND，所以手机端的USB OTG控制器读取到ID的状态为低，因此手机就作为主设备。而U盘端ID悬空，故被当做从设备B。
总结：
当设备检测到USB_ID信号为低时，该设备应作为Host（主机，也称A设备）用。
当设备检测到USB_ID信号为高时，该设备作为Slave(外设，也称B设备）用。
实际的USB连接线中，是没有USB_ID这根线的。 都是在接口部分直接拉死的的。
对于Host端，只需将连接线的USB_ID pin和地短接即可，
对于Slave端，USB连接线的USB_ID pin是悬空的。（设备内部上拉）。
--------------------- 
作者：小菜菜13 
来源：CSDN 
原文：https://blog.csdn.net/u010538116/article/details/80173538 
版权声明：本文为博主原创文章，转载请附上博文链接！




carplay 与carlife功能相同
eap 与aoa 功能相同




gpio controller(gc)
struct gpio_chip *gc;

pinctrl subsystem会维护一个gpio number到pin number的map
gpio number与 pin number的关系？
怎么提供gpio number和pin number的map呢？是通过一个名称为gpio range的数据结构(pinctrl subsystem提供的）



linux大文件分包压缩和批量解压命令tar
.gz格式
分包压缩：tar czf - xxx | split -b 1024m - xxx.tar.gz 	//xxx可以是文件也可以是目录， 大小可以是b、k、m这3个单位。
合包解压：cat xxx.tar.gz* | tar zvxf -

.bz2格式
分包压缩：tar -jcf - aaa | split -b 1400k - aaa.tar.bz2
合包解压：cat aaa.tar.bz2* | tar -jx -



Xargs用法详解
http://blog.chinaunix.net/uid-29792372-id-5188534.html
ls zh2.1_20180706.tar.gz* | xargs -i -t mv {} {}.zip


imx6q编译参数配置：
uboot和kernel参数都是BoardConfig.mk文件中配置的。

uboot参数配置：
	device/fsl/sabresd_6dq/BoardConfig.mk 文件中
		ifeq ($(TARGET_CUSTOMER_MODEL),FORYOU_S4)
		TARGET_BOOTLOADER_CONFIG := 6q:mx6q_sabresd_foryou_s4_android_config 6dl:mx6dl_sabresd_android_config
		endif 	
	
	TARGET_BOOTLOADER_CONFIG是在 build/core/Makefile：424行中被调用的。
		
		
		
kernel参数配置：
	device/fsl/imx6/soc/imx6dq.mk 文件中
		TARGET_KERNEL_DEFCONF := imx6_android_$(TARGET_CUSTOMER_MODEL)_defconfig
		
		TARGET_KERNEL_DEFCONF是在 build/core/Makefile：831行中被调用的。
		
source build/envsetup.sh		
lunch sabresd_6dq-user FORYOU_S4
 把第二个参数 FORYOU_S4 赋给 TARGET_CUSTOMER_MODEL 变量，根据该变量来决定项目编号的。

function lunch()
{
    local answer
if [ "$2" ] ; then
echo ""
echo ""
echo "current project is $2"
echo ""
export TARGET_CUSTOMER_MODEL=$2
...
}



imx8系统编译环境配置：
1.anzhuang ubuntu 16.04


2.anzhuang sougou shurufa
	https://blog.csdn.net/areigninhell/article/details/79696751


3.anzhuang virturalbox
	https://blog.csdn.net/weixin_43331296/article/details/83025126

4.anzhuang source insight
	https://blog.csdn.net/imyang2007/article/details/7654700
	
5.source insight 新建工程
	https://blog.csdn.net/toddmi/article/details/7731512

6.








	How to Generate an SSH Key
	 

    From the Terminal or Git Bash, run ssh-keygen
    Confirm the default path .ssh/id_rsa
    Enter a passphrase (recommended) or leave it blank.
    Remember this passphrase, as you will need it to unlock the
    key whenever you use it.
    Open ~/.ssh/id_rsa.pub and copy & paste the contents into
    the box below, then click on "Add".
    Note that id_rsa.pub is your public key and can be shared,
    while id_rsa is your private key and should be kept secret.


yzp@yzp-B85M-D2V:~$ du -sh imx-p9.0.0_2.1.0-auto-ga_a/
71G	imx-p9.0.0_2.1.0-auto-ga_a/


ubuntu如何安装gcc-arm-none-eabi:
https://jingyan.baidu.com/article/eae078276fe0781fec5485e9.html


ubuntu 安装cmake
wget https://github.com/Kitware/CMake/releases/download/v3.13.2/cmake-3.13.2.tar.gz
tar -xzvf cmake-3.13.2.tar.gz; cd cmake-3.13.2;
sudo ./bootstrap
sudo make
sudo make install



Ubuntu 安装adb
https://blog.csdn.net/u011006622/article/details/77505444

ubuntu Virtualbox识别USB设备
https://www.cnblogs.com/ljjphysics/archive/2012/07/02/2572746.html



串口调试利器--Minicom配置及使用详解
https://www.cnblogs.com/wonux/p/5897127.html
https://www.cnblogs.com/pipci/p/8474188.html
ctrl-a + z 	//帮助信息
ctrl-a + L 	//开始、停止打印保存为文件
ctrl-a + o 	//设置串口信息
ctrl-a + q 	//退出minicom应用
ctrl-a + x 	//退出minicom应用


VirtualBox启动报错--execute the kernel module by executing '/sbin/vboxconfig'的解决方法
https://blog.csdn.net/ximingren/article/details/79200828






yzp@yzp-B85M-D2V:~/imx-p9.0.0_2.1.0-auto-ga_a$ lsusb
Bus 002 Device 002: ID 8087:8000 Intel Corp. 
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 8087:8008 Intel Corp. 
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 014: ID 067b:2303 Prolific Technology, Inc. PL2303 Serial Port
Bus 003 Device 015: ID 18d1:4ee7 Google Inc. 
Bus 003 Device 003: ID 093a:2510 Pixart Imaging, Inc. Optical Mouse
Bus 003 Device 004: ID 1c4f:0002 SiGma Micro Keyboard TRACER Gamma Ivory
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
yzp@yzp-B85M-D2V:~/imx-p9.0.0_2.1.0-auto-ga_a$ 



当mxc_v4l2_capture.c中的open函数中调用vidioc_int_g_ifparm的话，
	v4l2_int_ioctl_1(struct v4l2_int_device *d, int cmd, void *arg)
		find_ioctl();			//返回对应的v4l2_int_ioctl_func类型的处理函数




#define V4L2_INT_WRAPPER_1(name, arg_type, asterisk)			\
	static inline int vidioc_int_##name(struct v4l2_int_device *d,	\
					    arg_type asterisk arg)	\
	{								\
		return v4l2_int_ioctl_1(d, vidioc_int_##name##_num,	\
					(void *)(unsigned long)arg);	\
	}



struct v4l2_int_ioctl_desc {
	int num;
	v4l2_int_ioctl_func *func;
};

所以，struct v4l2_int_ioctl_desc中的num和func是由name决定的。
这个vidioc_int_##name##_num描述就定义了一个num(vidioc_int_g_ifparm_num这样的序号值), 
这个vidioc_int_##name描述就定义了一个func(vidioc_int_g_ifparm这样的处理函数)



 V4L2_CAP_VIDEO_OVERLAY与V4L2_CAP_VIDEO_CAPTURE的区别
https://blog.csdn.net/weixin_30788619/article/details/96341714
		

uuu工具烧录：
sudo ./uuu_imx_android_flash.sh -f imx8qxp -e




fastboot工具烧录：
sudo ./fastboot_imx_flashall.sh -f imx8qxp -a -e -D /imx_pi9.0/mek_8q_car/


usb驱动开发之USB协议枚举过程详解
https://blog.csdn.net/charliewangg12/article/details/77890741

Linux驱动发开，usb设备的probe全过程
https://blog.csdn.net/kevinx_xu/article/details/23513117






uboot和kernel参数都是BoardConfig.mk文件中配置的。

uboot参数配置：
	device/fsl/sabresd_6dq/BoardConfig.mk 文件中
		ifeq ($(TARGET_CUSTOMER_MODEL),FORYOU_S4)
		TARGET_BOOTLOADER_CONFIG := 6q:mx6q_sabresd_foryou_s4_android_config 6dl:mx6dl_sabresd_android_config
		endif 	
	
	TARGET_BOOTLOADER_CONFIG是在 build/core/Makefile：424行中被调用的。
		
		
		
kernel参数配置：
	device/fsl/imx6/soc/imx6dq.mk 文件中
		TARGET_KERNEL_DEFCONF := imx6_android_$(TARGET_CUSTOMER_MODEL)_defconfig
		
		TARGET_KERNEL_DEFCONF是在 build/core/Makefile：831行中被调用的。
		
		
		
		
# set sdp command name based on soc_name
if [[ ${soc_name#imx8q} != ${soc_name} ]]; then		//如果是imx8q系列的soc，那就执行sdp="SDPS"
    sdp="SDPS"
fi		

解析：
https://blog.csdn.net/qq_43193797/article/details/90906007


FB 的意思是 ：fastboot

echo FB: flash gpt 				partition-table.img >> /tmp/uuu.lst			//把partition-table.img烧录进gpt分区，可是为什么从文档分区表中没看见有gpt分区？
echo FB: flash bootloader0 		spl-imx8qxp.bin >> /tmp/uuu.lst
echo FB: flash bootloader_a		bootloader-imx8qxp.img >> /tmp/uuu.lst
echo FB: flash dtbo_a			dtbo-imx8qxp.img >> /tmp/uuu.lst
....



在Windows上安装xshell，并ssh虚拟机Ubuntu
https://blog.csdn.net/dengjin20104042056/article/details/79123387



深入理解 Android 系统升级
https://blog.csdn.net/owenchan1987/article/details/77651954

grep -rni "bootimage" ./
grep -Rni "bootimage" ./

使用 -R 查找的结果更详细，grep命令使用-R参数


lunch:   lunch <product_name>-<build_variant>

Android系统编译流程：
三：make命令的执行过程：
	1. 到device和vendor目录下查找所有的AndroidProducts.mk文件，并将所有AndroidProducts.mk文件路径赋值给PRODUCT_MAKEFILES 变量




全编译：
	make -j4
Building U-Boot images：
	make bootloader -j4
	
Building a kernel image：
	make bootimage -j4
	
Building dtbo.img：
	make dtboimage -j4








/*
 * Legacy format image header,
 * all data in network byte order (aka natural aka bigendian).
 */
typedef struct image_header {
	uint32_t	ih_magic;	/* Image Header Magic Number	*/ 
	uint32_t	ih_hcrc;	/* Image Header CRC Checksum	*/
	uint32_t	ih_time;	/* Image Creation Timestamp	*/
	uint32_t	ih_size;	/* Image Data Size		*/
	uint32_t	ih_load;	/* Data	 Load  Address		*/
	uint32_t	ih_ep;		/* Entry Point Address		*/
	uint32_t	ih_dcrc;	/* Image Data CRC Checksum	*/
	uint8_t		ih_os;		/* Operating System		*/
	uint8_t		ih_arch;	/* CPU architecture		*/
	uint8_t		ih_type;	/* Image Type			*/
	uint8_t		ih_comp;	/* Compression Type		*/
	uint8_t		ih_name[IH_NMLEN];	/* Image Name		*/
} image_header_t;



其中，ih_load；加载地址，表示内核运行的时候先把它放在哪里。
     ih_ep；  入口地址，运行内核时，直接跳转到该地址执行，




















一个ＵＳＢ控制器和一个Ｈｕｂ绑定在一起，专业一点称为“集成”，这个ｈｕｂ也被称为RootHub.
USB协议规定所有的数据传输都必须由主机发起，
ＵＳＢ通信最基本的形式是通过ＵＳＢ设备中一个叫Ｅｎｄｐｏｉｎｔ（端点）的东西，而主机和端点之间的数据传输是通过Ｐｉｐｅ（管道）。

如图　Ｌｉｎｕｘ那些事之我是ＵＳＢ的１．６．５图所示，一个ＵＳＢ逻辑设备就是一系列端点的集合。它与主机之间的通信发生在主机上的一个缓冲区和设备上的一个端点之间，
通过管道来传输数据。也就是说，管道的一端是主机上的一个缓冲区，一端是设备上的端点。

ｄｒｉｖｅｒｓ/usb/目录下放了很多目录，
ｃｏｒｅ目录，就专门放一些核心的代码，比如初始化整个ＵＳＢ系统，初始化ＲｏｏｔＨｕｂ，
ｈｏｓｔ目录，初始化主机控制器的代码
ＵＳＢ世界里一个主机控制器hcd(host control device)对应着一条ＵＳＢ总线，主机控制器驱动用　ｓｔｒｕｃｔ　usb_hｃｄ　结构表示，一条总线用　ｓｔｒｕｃｔ　usb_bus结构体表示。

基本上，ｄｒｉｖｅｒｓ/目录下面第一层的每个目录都算一个子系统，它们代表了一类设备。

