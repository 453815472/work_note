额外补充,shell(not Makefile)：
1、$@
$@ 为传递的参数
2、$#
$# 为传递参数的数量

就像脚本执行后的结果：
 
Testing $@ and $#
-------------
Output $@
1.txt 2.txt
Output $#
2
3、$? 
    是shell变量,表示"最后一次执行命令"的退出状态，一般0表示成功，非0数值表示没有成功。
 
切记:
$?永远表示shell命令最后一次执行后的退出状态,当函数执行完毕后,如果又执行了其它命令,则$?不再表示函数执行后的状态,而表示其它命令的退出状态. 
4、$!
    代表pid,进程id
 
5、$$
    代表ppid,父进程id
	
	
	
	
	
	
1.使用IE g[器入下列W址
   https://firm.sunplus.com/
2.
账号zouhh   密码Li#98xy!


路剑http://carwiki.sunplus.com/index.php/SPHE_8388 	



单点触摸(Single-touch)设备支持以下Linux输入事件: 
ABS_X: (必须) ：报告工具的x坐标 
ABS_Y: (必须) ：报告工具的y坐标 
BTN_TOUCH: (必须) ：指示工具是否接触触摸设备. 

多点触摸(Multi-touch)设备支持以下Linux输入事件: 
ABS_MT_POSITION_X: (必须)： 报告工具的X坐标 
ABS_MT_POSITION_Y: (必须)： 报告工具的X坐标 
BTN_TOUCH: (必须) ： 指示工具是否接触触摸设备




插入iPhone手机，并没有点击车机的carlife软件图标，
1.	create /dev/iap ok
2.	create /dev/mfi_eap_carlife ok


root@Gemini:/sys/bus/usb/drivers# ls
adk_skeleton   snd-usb-audio  usb-storage    usbhid
hub            usb            usbfs          uvcvideo
基本上,drivers/目录下面第一层的每个目录都算一个子系统,因为它们代表了一类设备


.hub本身就是两种,一种是普通的hub,一种是root hub.
对于普通hub,它完全可能也是和U盘一样,在某个时刻被你插入,然后这种情况下hub_probe被调用,
但是对于root hub就不需要这么多废话了,root hub肯定是有的,只要你有host controller,就一定会有root hub,
所以hub_probe()基本上是很自然的就被调用了,不用说非得等待某个插入事件的发生,没这个必要.

问题：系统启动的时候，root hub 的probe 是怎么被调用的？
--------------------- 
只要你有usb host controller,那么在usb host controller的驱动程序初始化的过程中,它就会调用hub_probe()来探测root hub,
不管你的host controller是ohci,uhci,还是ehci的接口.


 kernel/drivers/mtd/mtdcore.c 的 mtd_erase/mtd_write_oob/mtd_write API，
 
 
 
 
 
 
 
 
 
 
 
 
下载repo
curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo -o repo
chmod +x repo

export REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/'
 
 重新运行的命令 
? For TCC897X/TCC802X
$ mkdir Linux_platform
$ cd Linux_platform
$ repo init -u ssh://git.telechips.com/linux_ivi/manifest.git -m als_v2.5.2.xml
$ repo sync
$ poky/download.sh
 
 
 
    git config --global user.email "yuzp@zhonghongcarav.com.cn"
    git config --global user.name "yuzp"
 
 
 
 
 黄锐胜:
就是开机动画的size，你邮件有收到我昨天发的B511无UI报告吗？

BOSS-YU-BEYOND:
你们改动了哪些内容，我需要了解一下

BOSS-YU-BEYOND:
有的，那个pdf

黄锐胜:
对的，

黄锐胜:
开机动画的size是固定的，xboot将animation_logo.bin放到DRAM

黄锐胜:
播放的时候会传address和size进去

黄锐胜:
这个时候我将size改变

黄锐胜:
按照原理来没有修正的code，会出现IPC timeout的问题

 
 
 
 yuzp@zhos-sw:~/work/Linux_platform$ poky/download.sh
This may take a long time depending on your network environment.
Continue? (Y/n) => Y
Choose ALS version
  1. als_v2.5.0
  2. als_v2.5.1
  3. als_v2.5.2
select number(1-3) => 3
Do you want to download tools(ADT, buildtools), too? (Y/n) => Y
Start tools downloading...done
Start source mirror downloading...done
Start others downloading...done
yuzp@zhos-sw:~/work/Linux_platform$ 
 
 

 
 ~/works/Yocto/release/ALS/build/tcc8971-lcn-2.0a$ ls -1 tmp/deploy/images/tcc8971-lcn-2.0a/
automotive-linux-platform-image-tcc8971-lcn-2.0a.ext4
zImage-tcc8971-linux-lcn-2.0a.dtb
initramfs-telechips-image-tcc8971-lcn-2.0a.cpio.gz
modules-tcc8971-lcn-2.0a.tgz
tc-boot-tcc8971-lcn-2.0a.img
lk-tcc8971-lcn-2.0a.rom
~/works/Yocto/release/ALS/build/tcc8971-lcn-2.0a$



Choose ALS version
1. als_v2.5.0
2. als_v2.5.1
3. als_v2.5.2
select number(1-3) => 3

TCC8971 DEMO BOARD 目前的ALS version： als_v2.5.2，几个疑问点，以下功能怎么添加：
1.	目前编译出来桌面只有一个AV Play应用，可以在编译的时候选择更多应用吗
2.触摸屏功能怎么开启
3.倒车，音乐声音输出
4.aux in
5.蓝牙、WiFi
6。usb、sd卡
7.录音功能



export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./


内核source code 路径：
yuzp@zhos-sw:~/work/Linux_platform/build/tcc8971-lcn-2.0a/tmp/work-shared/tcc8971-lcn-2.0a/kernel-source$ ls
Z:\Linux_platform\build\tcc8971-lcn-2.0a\tmp\work\tcc8971_lcn_2.0a-telechips-linux-gnueabi\linux-telechips\3.18.24-r0\git

little kernel 源码路径：
Z:\Linux_platform\build\tcc8971-lcn-2.0a\tmp\work\cortexa7-neon-telechips-linux-gnueabi\lk-dt\1.0.0-r0\git



每次开启服务器，重新建立环境需要执行的动作：

 source buildtools/environment-setup-x86_64-pokysdk-linux
 
 source poky/als-build.sh
 
 export TEMPLATECONF=~/works/Yocto/release/ALS/poky/meta-telechips/template
 
 source poky/oe-init-build-env build/tcc8971-lcn-2.0a
 
  bitbake automotive-linux-platform-image
  
  
  
  
  设置交叉编译器环境：
  source ../adt/environment-setup-cortexa7-neon-telechips-linux-gnueabi
  
  终端输入arm-telechips-linux-gnueabi 按tab键 就会有补充
  
  
  
  adt安装默认路径：
  Enter target directory for SDK (default: /opt/poky-telechips-systemd/nodistro.0):
  
  
那么这个重复打印的原因是服务被重复开启了？	是的
那么这个重复打印的原因是服务被重复开启了？  是的

配置内核的命令：
bitbake -c menuconfig linux-telechips

这两条命令是干什么的？
bitbake -c cleanall linux-telechips
bitbake linux-telechips

生成镜像所在位置：
ls -1 tmp/deploy/images/tcc8971-lcn-2.0a/



Telechips Issue Management System：
https://tims.telechips.com:8443/secure/Dashboard.jspa

tims账号密码：
Username:
    yuzp@zhonghongcarav.com.cn 
password：
	zhonghong2018
	
注意
不要求图层名称以前缀开头meta-，但它是Yocto项目社区中普遍接受的标准。	
	
	
BitBake User Manual
		https://www.yoctoproject.org/docs/2.5.1/bitbake-user-manual/bitbake-user-manual.html#bitbake-user-manual-command
		
FTP_addr="rf.telechips.com"
FTP_user="customer"
FTP_pass="telecustomer12!"
DL_SOURCE_MIRROR_DIR="source-mirror"
ALS_VERSIONS="als_v2.5.0 als_v2.5.1 als_v2.5.2"


ncftp -u customer -p telecustomer12! rf.telechips.com


黄锐胜:
支持ISP需要满足这3个条件

一个partition，FAT32，扇区大小512



list_for_each_entry(d, &core_list, node)
/*记忆方法：core_list 是链表头，node是链表上的节点，d 是包含node成员的结构体。意思就是 从core_list链表头开始遍历每一个节点，就可以找到每一个d 结构体了*/



单独编译内核：
	bitbake linux-telechips

单独编译设备树：	
	
	
单独编译uboot：
	bitbake lk-dt
	
		
单独编译rootfs:
	
		
		
		
initramfs-telechips-image-tcc8971-lcn-2.0a.cpio.gz
modules-tcc8971-lcn-2.0a.tgz
 这两个是什么文件？	
 
  yocto-layer create layer_name创建一个新层
  
  
   3. 编译内核

         配置menuconfig指令：
        bitbake -c menuconfig -v linux-imx 
  
        单独编译kernel、模块、设备树
        bitbake -c compile -f -v linux-imx 
        bitbake linux-imx -c compile_kernelmodules -f -v    
        bitbake -c deploy -f -v linux-imx  

若要编译文件系统则用下面总指令
        bitbake core-image-minimal

         单独编译u-boot
        bitbake -c compile -f -v u-boot-imx
        bitbake -c deploy -f -v u-boot-imx
		

yocto project development manual		
https://www.yoctoproject.org/docs/2.2/dev-manual/dev-manual.html#new-recipe-writing-a-new-recipe		

Yocto Project Linux Kernel Development Manual 关键字：patch
https://www.yoctoproject.org/docs/2.0.1/kernel-dev/kernel-dev.html#applying-patches
		
bitbake 使用指南		
https://blog.csdn.net/lu_embedded/article/details/80634368


Yocto Bitbake的clean与cleanall以及cleansstate的区别
https://www.kancloud.cn/digest/yocto/138630

bitbake详解
https://blog.csdn.net/archer1991/article/details/62423014

bitbake语法
https://www.yoctoproject.org/docs/2.2/bitbake-user-manual/bitbake-user-manual.html#bitbake-user-manual-metadata


yocto的初始化脚本解释
https://blog.csdn.net/groundhappy/article/details/51307225


Yocto Project Development Environment
https://www.yoctoproject.org/docs/2.2/ref-manual/ref-manual.html#closer-look


Yocto Project Reference Manual 
https://www.yoctoproject.org/docs/2.2/ref-manual/ref-manual.html#usingpoky-debugging-tools-and-techniques



3.1.3. Setting a default value (?=)
3.1.4. Setting a weak default value (??=)
3.1.5. Immediate variable expansion (:=)
3.1.6. Appending (+=) and prepending (=+) With Spaces					,immediate effect during parsing
3.1.7. Appending (.=) and Prepending (=.) Without Spaces				,immediate effect during parsing
3.1.8. Appending and Prepending (Override Style Syntax)，Without Spaces	,effects are deferred until after parsing completes rather than being immediately applied.
		B_append 、C_prepend, 这些运算符与":=", ".=", "=.", "+=", and "=+"运算符的不同之处在于，它们的效果会延迟到解析完成后而不是立即应用。
3.1.9. Removal (Override Style Syntax)， Without Spaces
		FOO = "123 456 789 123456 123 456 123 456"
		FOO_remove = "123"
		FOO_remove = "456"
		FOO2 = "abc def ghi abcdef abc def abc def"
		FOO2_remove = "abc def"
		The variable FOO becomes "789 123456" and FOO2 becomes "ghi abcdef". 
3.1.10. Override Style Operation Advantages
		与 "+=" and "=+" 运算符相比，覆盖样式操作“_append”，“_ prepend”和“_remove”的一个优点是覆盖样式运算符提供了更有保证的操作。




例题：
     A = "1"
     A_append = "2"
     A_append = "3"
     A += "4"
     A .= "5"
答案：A becoming "1 4523".



		
配方（recipes）文件（后缀为 .bb）	
配方（recipes）的类文件（后缀为 .bbclass）
所有的配方文件都自动继承了 base.bbclass。base.bbclass 提供了大部分 bitbake 任务的默认实现。
一个配方文件可以继承多个类文件。
conf 目录包含编译系统的配置文件（后缀为 .conf）
BitBake允许通过include文件（.inc）和类文件（.bbclass）共享元数据。

BitBake允许通过include文件（.inc）和类文件（.bbclass）共享元数据。例如，假设您有一个常用功能，比如要在多个recipe之间共享的任务。在这种情况下，创建包含公共功能的.bbclass文件，然后在配方中使用inherit指令继承类是共享任务的常用方法。
BitBake提供的相应的机制，允许您在配方之间共享功能。 具体来说，机制包括include，inherit，INHERIT和require指令。

注意
inherit指令 继承类（.bbclass）的功能,该指令操作的对象是.bbclass文件。

include无法找到文件时， 该指令不会产生错误。因此，建议如果您要包含的文件存在，则应使用 require 而不是include。这样做可确保在找不到文件时产生错误。操作对象是.inc、.bb

require 指令。该指令的行为与include指令类似， 但如果无法找到要包含的文件，则BitBake会引发解析错误。操作对象是.inc、.bb

INHERIT 配置指令。仅在配置文件（.conf）中使用，与inherit指令一样操作的对象是.bbclass文件。
假设您需要继承abc.bbclass从配置文件调用的类文件，如下所示：

     INHERIT + =“abc”
	 
注意
因为.conf在BitBake执行期间首先解析文件，所以使用 INHERIT继承类有效地继承全局类（即所有配方）	 


require recipes-kernel/linux/linux-dtb.inc
require conf/machine/include/tune-cortexa7.inc

note：
require 文件的路径，相当于C语言中的include，也是有默认目录和当前目录 2种搜索路径的。
1.以 poky\meta\ 为顶层目录，即默认搜索目录。
2.以当前目录下搜索


inherit kernel
note：
inherit 文件的路径，都是poky\meta\classes\目录下。

--------------------- 

Overrides and override-style 可以应用于任何shell函数，而不仅仅是 任务

软件包 B 在构建时可能依赖软件包 A 提供的头文件、库文件，也可能要使用软件包 C 生成的工具。我们必须在配方文件中用“DEPENDS”变量声明构建时的依赖关系。
recipe(.bb)、append(.bbappend)、configuration(.conf)、include(.inc) 和 class(.bbclass) 文件	


附加文件(Append Files)

附加文件是具有.bbappend文件扩展名的文件，用于扩展或覆盖现有配方文件中的信息。
BitBake期望每个附加文件具有相应的配方文件。此外，附加文件和相应的配方文件必须使用相同的根文件名，只能在使用的文件类型后缀方面有所不同（例如formfactor_0.0.bb和formfactor_0.0.bbappend）。
附加文件中的信息将会扩展或覆盖匹配的的配方文件中的信息。
在命名附加文件时，可以使用通配符（％）来匹配配方文件名称。例如，假设您有一个如下的追加文件：
　　busybox_1.21.％.bbappend
该附加文件将匹配任何busybox_1.21.x.bb版本的配方文件。因此，附加文件将匹配以下配方名称：
　　busybox_1.21.1.bb
　　busybox_1.21.2.bb
　　busybox_1.21.3.bb
如果busybox的配方更新为busybox_1.3.0.bb，则附加文件名称将不匹配。但是，如果你命名了附加文件为busybox_1.％.bbappend，那么你将会依然匹配busybox_1.3.0.bb文件。
在通常情况下，您可以将附加文件命名为busybox _％.bbappend。这样简单，完全独立于版本。
--------------------- 
作者：勇敢的心2013 
来源：CSDN 
原文：https://blog.csdn.net/archer1991/article/details/62423014 
版权声明：本文为博主原创文章，转载请附上博文链接！


linux-telechips                                   :3.18.24-r0                          
linuxdoc-tools-native                              :0.9.69-r0                          
lk                                                  :1.0.0-r0                          
lk-dt                                               :1.0.0-r0                          
lk-tcc                                              :1.0.0-r0                          


u-boot-mkimage                                   1:2017.11-r0                          
u-boot-mkimage-native                            1:2017.11-r0                  


 $ {PN} / $ {EXTENDPE} $ {PV} - $ {PR}
 foo / 1.3.0-r0
 
 
　　PN：配方名称	foo
　　PV：配方版本	1.3.0
　　PR：配方修订版 	r0
	recipe name (PN) and version (PV)


 
install -d ${D}${bindir}
| xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
| D:/opt/disk3/yuzp/test2/als_v2.5.2_2/build/tcc8971-lcn-2.0a/tmp/work/cortexa7-neon-telechips-linux-gnueabi/yuzp-demo/0.1-r0/image
| bindir:/usr/bin
{libdir}:/usr/lib
{includedir}:/usr/include


在recipes中加入打印信息，有两种方式
    一种是Python形式，该形式可在console上打印出来: bb.plain, bb.note, bb.warn, bb.error, bb.fatal, bb.debug
    另一种是bash形式，该形式会在temp目录下的log中包含，需要inherit logging(base.bbclass会包含，通常不需要特意添加): bbplain, bbnote, bbwarn, bberror, bbfatal, bbdebug
		 bbnote "1111111111111111"			//不会输出到console
		bbplain "222222222222222222"		//白色字体 输出到console
		 bbwarn "D:${D}"					//黄色的警告字体 输出到console
		 bberror "binder:${bindir}"			//报错，不会继续往下编译
	包依赖中带有-native的表示这些包被host使用。
    比如bb文件中包含如下语句： DEPENDS += "lzop-native bc-native" 表示lzop和bc将会被host使用。
	
	


Yocto tips (5): Yocto如何更改source code的下载与git clone地址
https://blog.csdn.net/sy373466062/article/details/50363537


yocto  .bb file SRC_URI
https://community.nxp.com/thread/392020

Yocto更改源码的获取位置与git clone 地址
https://blog.csdn.net/yangteng0210/article/details/82022938?utm_source=blogxgwz3


xargs 命令


git commit 有弹框进入vim，填写信息 然后ctrl+o,回车保存，再ctrl+x退出

git查看远程仓库地址命令
git remote -v

file：//-从本地获取文件，这些文件通常是元数据附带的文件。其路径相对于FILESPATH变量。
因此，构建系统按顺序从配方文件（.bb）或附加文件（.bbappend）所在的目录的子目录中搜索：


./meta-telechips/meta-bsp/conf/machine/tcc897x.inc:39:KBUILD_DEFCONFIG ??= "tcc897x_linux_avn_lcn_defconfig"

./meta-telechips/meta-bsp/conf/machine/tcc8971-lcn-2.0a.conf:9:KBUILD_DEFCONFIG ??= "${@bb.utils.contains('INVITE_PLATFORM', 'fastboot', 'tcc897x_linux_avn_lcn2_reduce_defconfig', 'tcc897x_linux_avn_lcn2_defconfig', d)}"



			bitbake -C compile <target>
            注意：这里使用了-C，表示编译该task后，再编译所有的task。等效于
                bitbake -c compile <target>
                bitbake <target>
				
				
				

PROVIDES 用于提供配方的别名。

以配方文件libav_0.8.11.bb为例，libav_0.8.11.bb中的PROVIDES语句如下：

PROVIDES + =“libpostproc”

该PROVIDES语句使得“libav”配方也被称为“libpostproc”。



DEPENDS		列出配方的构建时的依赖项（即其他配方文件）。
RDEPENDS	列出包的运行时依赖关系（即其他程序包）


tmp/work/tcc8971_lcn_2.0a-telechips-linux-gnueabi/linux-telechips/3.18.24-r0/temp/log.task_order	这个文件显示了编译 linux-yocto 执行的task 以及 task 的执行顺序。


bitbake automotive-linux-platform-image -c cleansstate
bitbake linux-telechips -c cleansstate
bitbake lk-dt -c cleansstate

bitbake initramfs-telechips-image -c cleansstate
bitbake telechips-image-update -c cleansstate
bitbake update-rootfs -c cleansstate
bitbake tc-updater -c cleansstate

bitbake -s |grep rootfs
bitbake customize-rootfs -c cleansstate
bitbake update-rootfs -c cleansstate




root@telechips-tcc8031:~# tc-write-misc
write 'boot-recovery' to /dev/disk/by-partlabel/misc finished
root@telechips-tcc8031:~#

/dev/disk/by-partlabel		这个地址可以查看分区

 local.conf中定义的变量都是全局变量
BitBake 是一个执行 python 和 shell 脚本的引擎；
BitBake 使用的 5 种文件类型（.bb，.bbclass，.bbappend，.conf 和 include 文件）；


构建时依赖 和 运行时依赖
 build-time dependencies, which are required when the software is built; 
 runtime dependencies, which are required to be installed on the target in order for the software to run. 


FILESPATH在查找file://配方中每个URI 指定的文件和补丁时，按指定的顺序 搜索每个目录 。
 The default value for the FILESPATH variable is defined in the base.bbclass class found in meta/classes in the Source Directory:

     FILESPATH = "${@base_set_filespath(["${FILE_DIRNAME}/${BP}", \
        "${FILE_DIRNAME}/${BPN}", "${FILE_DIRNAME}/files"], d)}"
                    



If the first recipe is named a_1.1.bb, then the PN variable will be set to “a”, and the PV variable will be set to 1.1.
a recipe called "something_1.2.3.bb" would set PN to "something" and PV to "1.2.3".




BBPATH is used to search for configuration and class files under the conf and classes directories.
BBFILES is used to locate both recipe and recipe append files (.bb and .bbappend). 
BBPATH用于分别搜索conf和classes 目录下的配置和类文件 。 
BBFILES用于定位配方和配方附加文件（.bb和.bbappend）。


The PACKAGES variable lists the packages generated by a recipe.
The FILES variable lists the files and directories that are placed in a package.
The DEPENDS is a list of recipe names.
 example:

     FILES_${PN} += "${bindir}/mydir1 ${bindir}/mydir2/myfile"
	 
FILES :指定需要放入包中的目录或文件的列表。
使用FILES变量时，必须与生成包的包名结合使用。然后提供一个空格分隔的文件或路径列表，用于标识要包含在生成包中的文件。例如：

FILES _ $ {PN} + =“$ {bindir} / mydir1 / $ {bindir} / mydir2 / myfile”


The standard BitBake behavior in most cases is: do_fetch, do_unpack, do_patch, do_configure, do_compile, do_install, do_package, do_package_write_*, and do_build.


do_install() {
    install -d ${D}${libdir} ${D}${includedir}
    install -m 0644 ${S}/testlib1.so ${D}${libdir}
    install -m 0644 ${S}/testlib2.so ${D}${libdir}
    cp -ap ${S}/testlib.h ${D}${includedir}
	bbplain "[-yuzp-]{libdir}:${libdir}"
	bbplain "[-yuzp-]{includedir}:${includedir}"
}
//这个函数，是创建${D}${libdir} ${D}${includedir}目录，并向目录中分别拷贝文件。


PACKAGES = "${PN}"	//这句话的作用是指定包（packages)的名称。

FILES_${PN} += " \
    ${libdir}/*.so \
    ${includedir}/*.h \
"
//这句话是 指定需要放入包中的文件的列表。
//FILES 相对路径是${D}目录，即$ {WORKDIR} / image 下的目录及文件



The list of packages to be created from the recipe. The default value is the following:
 ${PN}-dbg ${PN}-staticdev ${PN}-dev ${PN}-doc ${PN}-locale ${PACKAGE_BEFORE_PN} ${PN}

 
 
oe-pkgdata-util list-pkgs [pattern]: Lists all packages that have been built, optionally limiting the match to packages that match pattern.
你可以使用标准*和？通配符通配符作为包名称和路径的一部分。
oe-pkgdata-util list-pkgs 				//查看所有package
oe-pkgdata-util list-pkgs helloworld	//查看是否有这个package





oe-pkgdata-util list-pkg-files package ...: Lists the files and directories contained in the given packages.
$oe-pkgdata-util list-pkg-files testlib	//查看package中文件和目录的列表
testlib:
	/usr/include/testlib.h
	/usr/lib/testlib1.so
	/usr/lib/testlib2.so


查看包内容的另一种方法是查看 如下所示：
${WORKDIR}/packages-split directory of the recipe that generates the package. This directory is created by the do_package task
If you want to inspect the ${WORKDIR}/packages-split directory, make sure that rm_work is not enabled when you build the recipe.


oe-pkgdata-util lookup-recipe package ...: Lists the name of the recipes that produce the given packages.
$oe-pkgdata-util lookup-recipe testlib	//查看package是属于哪个recipe





构建过程中的这一步包含三个任务：
do_configure：

do_compile： 一旦配置任务满足，BitBake就会使用do_compile 任务编译源代码 。编译发生在B 变量指向的目录中 。意识到B目录，默认情况下，在相同 S 目录下。

do_install： 编译完成后，BitBake执行 do_install 任务。此任务从B 目录复制文件并将它们放在D 变量指向的保留区域中 。


The TOPDIR variable points to the Build Directory.


"Package Feeds"目录：
tmp\deploy\rpm\cortexa7_neon\



STAMP 设置在meta/conf/bitbake.conf：

     STAMP =“$ {STAMPS_DIR} / $ {MULTIMACH_TARGET_SYS} / $ {PN} / $ {EXTENDPE} $ {PV}  -  $ {PR}”



























/*-------------------------------------------------------------------------------------
如 meta-tutorial/classes/mybuild.bbclass：
addtask build
mybuild_do_build () {
 
  echo "running mybuild_do_build."
 
}
 
EXPORT_FUNCTIONS do_build

在 base.class 中，我们添加了一个 build task，它也是一个简单的 shell 函数。mybuild_do 前缀的依据是 class 中 task 定义的规范 classname_do_functionname。
EXPORT_FUNCTIONS 使该 build 函数可被这个 class 的使用者使用，如果不添加这行，则它不会覆盖 base class 中的 build 函数。
--------------------------------------------------------------------------------------------------------------------------------------------------------*/


do_set_kernel_defconfig() {
	# 把 arch/arm/configs/tcc897x_linux_avn_lcn2_reduce_defconfig 拷贝为 defconfig(所在目录 tmp\work\tcc8971_lcn_2.0a-telechips-linux-gnueabi\linux-telechips\3.18.24-r0\ )
	#	
	if [ -n "${KBUILD_DEFCONFIG}" ]; then
		bbplain "[-yuzp-]linux-telechips.inc WORKDIR:${WORKDIR}"
		if [ -f "${S}/arch/${ARCH}/configs/${KBUILD_DEFCONFIG}" ]; then
			if [ -f "${WORKDIR}/defconfig" ]; then
			    bbnote "defconfig detected in WORKDIR. ${KBUILD_DEFCONFIG} skipped"
			else
				cp -f ${S}/arch/${ARCH}/configs/${KBUILD_DEFCONFIG} ${WORKDIR}/defconfig
			fi
		else
			bbfatal "A KBUILD_DECONFIG '${KBUILD_DEFCONFIG}' was specified, but not present in the source tree"
		fi
	fi
}



aaaaaaaaaaaaaaaa